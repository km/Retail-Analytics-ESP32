<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Retail Dashboard</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --muted: #6b7280;
        --text: #e5e7eb;
        --primary: #60a5fa;
        --primary-200: #bfdbfe;
        --green: #34d399;
        --red: #f87171;
        --yellow: #fbbf24;
        --border: #1f2937;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        --radius: 12px;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background: radial-gradient(1200px 800px at 20% -10%, #172554, #0b1220)
            no-repeat,
          var(--bg);
        color: var(--text);
      }
      header {
        padding: 24px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary), #22d3ee);
        box-shadow: 0 0 12px rgba(34, 211, 238, 0.6);
      }
      h1 {
        font-size: 18px;
        margin: 0;
        letter-spacing: 0.4px;
      }
      .container {
        padding: 20px;
        max-width: 1200px;
        margin: 0 auto;
      }
      .controls {
        background: rgba(17, 24, 39, 0.8);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 16px;
        box-shadow: var(--shadow);
        display: grid;
        grid-template-columns: 1.3fr 1fr 0.8fr 0.9fr 1fr;
        gap: 12px;
        align-items: end;
      }
      .controls .field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      input[type="text"],
      input[type="date"],
      input[type="number"],
      input[type="range"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        background: #0b1020;
        border: 1px solid var(--border);
        color: var(--text);
        outline: none;
      }
      .btn {
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b1020;
        color: var(--text);
        cursor: pointer;
        transition: 0.15s ease;
      }
      .btn.primary {
        background: linear-gradient(135deg, var(--primary), #22d3ee);
        color: #0b1020;
        border: none;
      }
      .btn:hover {
        transform: translateY(-1px);
        filter: brightness(1.05);
      }
      .toolbar {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }
      .status {
        margin-top: 14px;
        font-size: 12px;
        color: var(--muted);
      }
      .grid {
        margin-top: 20px;
        display: grid;
        grid-template-columns: 1.2fr 0.8fr;
        gap: 16px;
      }
      .panel {
        background: rgba(17, 24, 39, 0.8);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 16px;
        box-shadow: var(--shadow);
      }
      .panel h2 {
        margin: 0 0 10px 0;
        font-size: 16px;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 12px;
      }
      .stat {
        background: #0b1020;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
      }
      .stat .label {
        font-size: 11px;
        color: var(--muted);
      }
      .stat .value {
        margin-top: 6px;
        font-size: 18px;
      }
      .bad {
        color: var(--red);
      }
      .good {
        color: var(--green);
      }
      .warn {
        color: var(--yellow);
      }
      canvas {
        width: 100% !important;
        height: 360px !important;
      }
      .error {
        margin-top: 12px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: #fecaca;
        display: none;
      }
      .muted {
        color: var(--muted);
        font-size: 12px;
        margin-top: 6px;
      }
      @media (max-width: 1000px) {
        .controls {
          grid-template-columns: 1fr 1fr;
        }
        .grid {
          grid-template-columns: 1fr;
        }
        .stats {
          grid-template-columns: 1fr 1fr;
        }
        canvas {
          height: 300px !important;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="brand">
        <div class="dot"></div>
        <h1>Retail Analytics Dashboard</h1>
      </div>
      <div class="status" id="tzInfo"></div>
    </header>

    <div class="container">
      <div class="controls">
        <div class="field">
          <label>API Key</label>
          <input type="text" id="apiKey" placeholder="Paste API Key" />
          <div class="toolbar">
            <button class="btn" id="saveKeyBtn">Save Key</button>
            <button class="btn" id="testKeyBtn">Test Key</button>
          </div>
        </div>

        <div class="field">
          <label>Date</label>
          <input type="date" id="datePicker" />
          <div class="toolbar">
            <button class="btn" id="prevDayBtn">Prev Day</button>
            <button class="btn" id="nextDayBtn">Next Day</button>
          </div>
        </div>

        <div class="field">
          <label>Fetch Count (events)</label>
          <input
            type="number"
            id="countInput"
            min="50"
            max="20000"
            step="50"
            value="5000"
          />
          <div class="muted">
            Larger counts improve pairing accuracy (entry→exit).
          </div>
        </div>

        <div class="field">
          <label>Smoothing (K, Bayesian prior strength)</label>
          <input type="range" id="smoothK" min="0" max="20" step="1" value="5" />
          <div class="toolbar">
            <span class="muted"
              >K=<span id="smoothKVal">5</span> (higher = more smoothing)</span
            >
          </div>
        </div>

        <div class="field">
          <label>&nbsp;</label>
          <button class="btn primary" id="refreshBtn">Refresh</button>
          <div class="toolbar">
            <button class="btn" id="todayBtn">Today</button>
            <button class="btn" id="nowBtn">Use Now</button>
          </div>
        </div>
      </div>

      <div id="errorBox" class="error"></div>

      <div class="grid">
        <div class="panel">
          <h2>Entries / Exits by Hour (Selected Day)</h2>
          <canvas id="hourChart"></canvas>
          <div class="muted" id="eventsMeta"></div>
        </div>

        <div class="panel">
          <h2>Average Time Spent by Hour of Entry (minutes)</h2>
          <canvas id="dwellChart"></canvas>
          <div class="muted">
            Average session duration computed from entry→exit pairs. Bayesian
            shrinkage blends each hour with the day's overall mean when samples
            are few.
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top: 16px">
        <h2>Summary</h2>
        <div class="stats">
          <div class="stat">
            <div class="label">Total Events (fetched)</div>
            <div class="value" id="statEvents">—</div>
          </div>
          <div class="stat">
            <div class="label">Entries / Exits (in day)</div>
            <div class="value" id="statInOut">—</div>
          </div>
          <div class="stat">
            <div class="label">Sessions (in day)</div>
            <div class="value" id="statSessions">—</div>
          </div>
          <div class="stat">
            <div class="label">Avg / Median Dwell (minutes)</div>
            <div class="value" id="statDwell">—</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      const pad2 = (n) => String(n).padStart(2, "0");
      const fmt = new Intl.NumberFormat();

      function endOfDayEpoch(dateStr) {
        //YYYY-MM-DD in local time
        const [y, m, d] = dateStr.split("-").map((x) => parseInt(x, 10));
        const dt = new Date(y, m - 1, d, 23, 59, 59, 999); //local
        return Math.floor(dt.getTime() / 1000);
      }

      function startOfDayEpoch(dateStr) {
        const [y, m, d] = dateStr.split("-").map((x) => parseInt(x, 10));
        const dt = new Date(y, m - 1, d, 0, 0, 0, 0); //local
        return Math.floor(dt.getTime() / 1000);
      }

      function toLocalHour(ts) {
        return new Date(ts * 1000).getHours(); 
      }

      function formatMinutes(mins) {
        if (!isFinite(mins)) return "—";
        if (mins < 1) return `${(mins * 60).toFixed(0)} sec`;
        if (mins < 60) return `${mins.toFixed(1)} min`;
        const h = Math.floor(mins / 60);
        const m = Math.round(mins % 60);
        return `${h}h ${pad2(m)}m`;
      }

      function percentile(arr, p) {
        if (!arr.length) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const idx = Math.min(
          sorted.length - 1,
          Math.max(0, Math.floor((p / 100) * sorted.length))
        );
        return sorted[idx];
      }

      async function fetchMovements({ apiKey, dateEpoch, count }) {
        const url = `/getMovements/?date=${encodeURIComponent(
          dateEpoch
        )}&count=${encodeURIComponent(count)}&api_key=${encodeURIComponent(
          apiKey
        )}`;
        const res = await fetch(url, { method: "GET" });
        if (!res.ok) {
          let detail = "";
          try {
            const j = await res.json();
            detail = j?.detail || JSON.stringify(j);
          } catch {
            detail = await res.text();
          }
          const msg =
            res.status === 401
              ? "Invalid API key"
              : `HTTP ${res.status} ${res.statusText}`;
          throw new Error(`${msg}${detail ? " – " + detail : ""}`);
        }
        const data = await res.json();
        if (!data || !Array.isArray(data.movements)) {
          throw new Error("Malformed response: missing movements[]");
        }
        // normalize to {timestamp, is_entry:boolean}
        return data.movements.map((m) => ({
          timestamp: Number(m.timestamp),
          is_entry: !!m.is_entry,
        }));
      }

      function groupEventsByHour(events, dayStart, dayEnd) {
        const entries = Array(24).fill(0);
        const exits = Array(24).fill(0);
        let inCount = 0,
          outCount = 0;
        for (const e of events) {
          if (e.timestamp >= dayStart && e.timestamp <= dayEnd) {
            const h = toLocalHour(e.timestamp);
            if (e.is_entry) {
              entries[h]++;
              inCount++;
            } else {
              exits[h]++;
              outCount++;
            }
          }
        }
        return { entries, exits, inCount, outCount };
      }

      function buildSessions(eventsAsc) {
        //pair entries with the next exit. Ignore inconsistent extra exits.
        const sessions = [];
        let inside = false;
        let entryTs = null;

        for (const e of eventsAsc) {
          if (e.is_entry) {
            if (!inside) {
              inside = true;
              entryTs = e.timestamp;
            } else {
              //duplicate entry without exit -> reset to the latest entry
              entryTs = e.timestamp;
            }
          } else {
            if (inside && entryTs != null && e.timestamp > entryTs) {
              sessions.push({
                entry: entryTs,
                exit: e.timestamp,
                durationSec: e.timestamp - entryTs,
              });
              inside = false;
              entryTs = null;
            } else {
              //exit without prior entry -> ignore
            }
          }
        }
        return sessions;
      }

      function sessionsInDay(sessions, dayStart, dayEnd) {
        //keep sessions whose entry AND exit both fall within the day
        return sessions.filter(
          (s) => s.entry >= dayStart && s.exit <= dayEnd && s.durationSec > 0
        );
      }

      function dwellByHourOfEntry(sessions) {
        //return {count[24], sumMin[24], meanRaw[24]}
        const count = Array(24).fill(0);
        const sumMin = Array(24).fill(0);
        for (const s of sessions) {
          const h = toLocalHour(s.entry);
          count[h]++;
          sumMin[h] += s.durationSec / 60;
        }
        const meanRaw = sumMin.map((sum, h) =>
          count[h] > 0 ? sum / count[h] : 0
        );
        return { count, sumMin, meanRaw };
      }

      function bayesianShrinkage(means, counts, globalMean, K) {
        //shrunk = (sum + K*global) / (n + K)
        const shrunk = means.map((m, h) => {
          const n = counts[h];
          return (m * n + K * globalMean) / (n + K || 1); //if n=0,K=0 -> avoid /0
        });
        return shrunk;
      }

      let hourChart = null;
      let dwellChart = null;

      function renderHourChart(data) {
        const ctx = $("hourChart").getContext("2d");
        const labels = Array.from({ length: 24 }, (_, i) => `${i}:00`);
        const dsEntries = {
          label: "Entries",
          data: data.entries,
          backgroundColor: "rgba(52, 211, 153, 0.7)",
          borderColor: "rgba(52, 211, 153, 1)",
          borderWidth: 1,
        };
        const dsExits = {
          label: "Exits",
          data: data.exits,
          backgroundColor: "rgba(248, 113, 113, 0.7)",
          borderColor: "rgba(248, 113, 113, 1)",
          borderWidth: 1,
        };

        if (hourChart) {
          hourChart.data.labels = labels;
          hourChart.data.datasets[0].data = dsEntries.data;
          hourChart.data.datasets[1].data = dsExits.data;
          hourChart.update();
          return;
        }

        hourChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels,
            datasets: [dsEntries, dsExits],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: "index", intersect: false },
            plugins: {
              legend: {
                labels: { color: "#e5e7eb" },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) =>
                    `${ctx.dataset.label}: ${fmt.format(ctx.parsed.y)}`,
                },
              },
            },
            scales: {
              x: {
                grid: { color: "rgba(255,255,255,0.06)" },
                ticks: { color: "#cbd5e1" },
              },
              y: {
                beginAtZero: true,
                grid: { color: "rgba(255,255,255,0.06)" },
                ticks: { color: "#cbd5e1" },
              },
            },
          },
        });
      }

      function renderDwellChart(rawMeans, shrunkMeans) {
        const ctx = $("dwellChart").getContext("2d");
        const labels = Array.from({ length: 24 }, (_, i) => `${i}:00`);

        const rawDs = {
          label: "Raw Average",
          data: rawMeans,
          borderColor: "rgba(191, 219, 254, 0.8)",
          backgroundColor: "rgba(191, 219, 254, 0.15)",
          borderWidth: 2,
          fill: false,
          tension: 0.25,
          pointRadius: 2,
        };

        const shrunkDs = {
          label: "Smoothed (Bayesian)",
          data: shrunkMeans,
          borderColor: "rgba(96, 165, 250, 1)",
          backgroundColor: "rgba(96, 165, 250, 0.15)",
          borderWidth: 3,
          fill: true,
          tension: 0.3,
          pointRadius: 3,
        };

        if (dwellChart) {
          dwellChart.data.labels = labels;
          dwellChart.data.datasets[0].data = rawDs.data;
          dwellChart.data.datasets[1].data = shrunkDs.data;
          dwellChart.update();
          return;
        }

        dwellChart = new Chart(ctx, {
          type: "line",
          data: {
            labels,
            datasets: [rawDs, shrunkDs],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: "index", intersect: false },
            plugins: {
              legend: { labels: { color: "#e5e7eb" } },
              tooltip: {
                callbacks: {
                  label: (ctx) =>
                    `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)} min`,
                },
              },
            },
            scales: {
              x: {
                grid: { color: "rgba(255,255,255,0.06)" },
                ticks: { color: "#cbd5e1" },
              },
              y: {
                beginAtZero: true,
                grid: { color: "rgba(255,255,255,0.06)" },
                ticks: {
                  color: "#cbd5e1",
                  callback: (v) => `${v}m`,
                },
              },
            },
          },
        });
      }

      function setError(msg) {
        const box = $("errorBox");
        if (!msg) {
          box.style.display = "none";
          box.textContent = "";
          return;
        }
        box.style.display = "block";
        box.textContent = msg;
      }

      function setTZInfo() {
        const tz =
          Intl.DateTimeFormat().resolvedOptions().timeZone || "Local time";
        $("tzInfo").textContent = `Time zone: ${tz}`;
      }

      function getSelectedDateStr() {
        return $("datePicker").value;
      }

      function setSelectedDateStr(dateStr) {
        $("datePicker").value = dateStr;
      }

      function shiftSelectedDate(days) {
        const d = new Date(getSelectedDateStr());
        d.setDate(d.getDate() + days);
        const s = `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(
          d.getDate()
        )}`;
        setSelectedDateStr(s);
      }

      function updateSmoothLabel() {
        $("smoothKVal").textContent = $("smoothK").value;
      }

      function setStats({
        fetchedCount,
        inCount,
        outCount,
        sessionsCount,
        avgMin,
        medMin,
      }) {
        $("statEvents").textContent = fmt.format(fetchedCount);
        $("statInOut").textContent = `${fmt.format(inCount)} / ${fmt.format(
          outCount
        )}`;
        $("statSessions").textContent = fmt.format(sessionsCount);
        $("statDwell").textContent = `${formatMinutes(
          avgMin
        )} avg • ${formatMinutes(medMin)} median`;
      }

      async function refresh() {
        try {
          setError("");
          const apiKey = $("apiKey").value.trim();
          const count = parseInt($("countInput").value, 10) || 5000;
          const dateStr = getSelectedDateStr();
          if (!apiKey) throw new Error("Please enter an API key.");
          if (!dateStr) throw new Error("Please select a date.");

          const dayEnd = endOfDayEpoch(dateStr);
          const dayStart = startOfDayEpoch(dateStr);

          const events = await fetchMovements({
            apiKey,
            dateEpoch: dayEnd,
            count,
          });

          $("eventsMeta").textContent = `Fetched ${
            events.length
          } events up to ${new Date(dayEnd * 1000).toLocaleString()}.`;

          //sort ascending for pairing logic
          const eventsAsc = [...events].sort(
            (a, b) => a.timestamp - b.timestamp
          );

          //chart 1: Entries/Exits by hour within the day
          const grouped = groupEventsByHour(eventsAsc, dayStart, dayEnd);
          renderHourChart(grouped);

          //pair sessions, then filter to sessions fully within the day
          const allSessions = buildSessions(eventsAsc);
          const daySessions = sessionsInDay(allSessions, dayStart, dayEnd);
          const durationsMin = daySessions.map((s) => s.durationSec / 60);

          const { count: counts, sumMin, meanRaw } =
            dwellByHourOfEntry(daySessions);

          //global mean for Bayesian shrinkage
          const totalSum = sumMin.reduce((a, b) => a + b, 0);
          const totalN = counts.reduce((a, b) => a + b, 0);
          const globalMean = totalN > 0 ? totalSum / totalN : 0;
          const K = parseInt($("smoothK").value, 10) || 0;
          const meanShrunk = bayesianShrinkage(meanRaw, counts, globalMean, K);

          renderDwellChart(meanRaw, meanShrunk);

          //Stats
          const avgMin =
            durationsMin.length > 0
              ? durationsMin.reduce((a, b) => a + b, 0) /
                durationsMin.length
              : 0;
          const medMin = percentile(durationsMin, 50);

          setStats({
            fetchedCount: events.length,
            inCount: grouped.inCount,
            outCount: grouped.outCount,
            sessionsCount: daySessions.length,
            avgMin,
            medMin,
          });
        } catch (err) {
          console.error(err);
          setError(err?.message || "Unexpected error while loading data.");
        }
      }

      function initDefaults() {
        //set default date to today
        const d = new Date();
        const todayStr = `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(
          d.getDate()
        )}`;
        setSelectedDateStr(todayStr);

        //Load API key from localStorage
        const savedKey = localStorage.getItem("apiKey");
        if (savedKey) $("apiKey").value = savedKey;

        setTZInfo();
        updateSmoothLabel();
      }

      $("saveKeyBtn").addEventListener("click", () => {
        const k = $("apiKey").value.trim();
        if (!k) return setError("API key is empty.");
        localStorage.setItem("apiKey", k);
        setError("");
      });

      $("testKeyBtn").addEventListener("click", async () => {
        try {
          setError("");
          const k = $("apiKey").value.trim();
          if (!k) throw new Error("Please enter an API key.");
          // Minimal test: try to fetch 1 event up to now
          const nowEpoch = Math.floor(Date.now() / 1000);
          await fetchMovements({ apiKey: k, dateEpoch: nowEpoch, count: 1 });
          setError("API key looks valid.");
        } catch (e) {
          setError(e.message);
        }
      });

      $("refreshBtn").addEventListener("click", refresh);
      $("prevDayBtn").addEventListener("click", () => {
        shiftSelectedDate(-1);
        refresh();
      });
      $("nextDayBtn").addEventListener("click", () => {
        shiftSelectedDate(1);
        refresh();
      });
      $("todayBtn").addEventListener("click", () => {
        const d = new Date();
        const s = `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(
          d.getDate()
        )}`;
        setSelectedDateStr(s);
        refresh();
      });
      $("nowBtn").addEventListener("click", () => {
        //Use "now" by setting date to today, but in practice we always query up to end-of-day
        //The end-of-day snapshot aligns to the selected date automatically.
        refresh();
      });
      $("smoothK").addEventListener("input", () => {
        updateSmoothLabel();
        //re-render with new smoothing without refetch
        $("refreshBtn").click();
      });

      $("countInput").addEventListener("change", () => {
        //re-fetch with new count
        $("refreshBtn").click();
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Enter") $("refreshBtn").click();
      });

      initDefaults();
      //auto-load on first open
      setTimeout(refresh, 50);
    </script>
  </body>
</html>